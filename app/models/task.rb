class Task < ApplicationRecord
  include Discard::Model
  include GitOperations
  include ActionView::RecordIdentifier

  belongs_to :project
  belongs_to :agent
  belongs_to :user
  has_many :runs, dependent: :destroy
  has_many :volume_mounts, dependent: :destroy

  after_create :create_volume_mounts
  after_create :generate_task_name
  before_validation :set_default_description, on: :create
  after_update_commit :broadcast_description_update, if: :saved_change_to_description?

  validates :description, presence: true

  accepts_nested_attributes_for :runs

  def run(prompt)
    run_instance = runs.create(prompt: prompt)
    run_instance
  end

  def workplace_mount
    @workplace_mount ||= volume_mounts.find_or_create_by!(volume: nil) do |vm|
      # volume_name will be generated by the before_validation callback
    end
  end

  def branches
    @branches ||= fetch_branches(self)
  end

  def total_cost
    runs.joins(:steps).where.not(steps: { cost_usd: nil }).sum("steps.cost_usd")
  end

  def total_tokens
    {
      input: runs.joins(:steps).where.not(steps: { input_tokens: nil }).sum("steps.input_tokens"),
      output: runs.joins(:steps).where.not(steps: { output_tokens: nil }).sum("steps.output_tokens"),
      cache_creation: runs.joins(:steps).where.not(steps: { cache_creation_tokens: nil }).sum("steps.cache_creation_tokens"),
      cache_read: runs.joins(:steps).where.not(steps: { cache_read_tokens: nil }).sum("steps.cache_read_tokens")
    }
  end

  def docker_env_strings(additional_vars = [])
    additional_env_array = case additional_vars
    when Hash
      additional_vars.map { |k, v| "#{k}=#{v}" }
    else
      Array(additional_vars)
    end
    
    agent.env_strings + project.env_strings + user.env_strings + additional_env_array
  end

  def latest_repo_state
    RepoState
      .joins(step: :run)
      .where(runs: { task_id: id })
      .order("runs.created_at DESC, steps.created_at DESC")
      .first
  end


  private

  def create_volume_mounts
    agent.volumes.each do |volume|
      volume_mounts.find_or_create_by!(volume: volume)
    end
    workplace_mount # Create workplace mount
  end

  def set_default_description
    self.description ||= "#{agent.name} in #{project.name}" if agent && project
  end

  def generate_task_name
    return unless user.auto_task_naming_agent
    return unless description == "#{agent.name} in #{project.name}"
    prompt = self.runs.first&.prompt
    return unless prompt
    AutoTaskNamingJob.perform_later(self, prompt)
  end

  def broadcast_description_update
    Rails.logger.info "Broadcasting description update for task #{id} to target: task_#{id}_description"

    # Try broadcasting to self (the task) as the stream source
    broadcast_replace_to(self, target: "task_#{id}_description", partial: "tasks/description", locals: { task: self })

    Rails.logger.info "Broadcast completed"
  rescue => e
    Rails.logger.error "Broadcast failed: #{e.message}"
  end
end
