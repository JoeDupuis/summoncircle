class Task < ApplicationRecord
  include Discard::Model
  include GitOperations

  belongs_to :project
  belongs_to :agent
  belongs_to :user
  has_many :runs, dependent: :destroy
  has_many :volume_mounts, dependent: :destroy

  after_create :create_volume_mounts
  before_validation :set_default_description, on: :create

  validates :description, presence: true

  accepts_nested_attributes_for :runs

  def run(prompt)
    runs.create(prompt: prompt)
  end

  def workplace_mount
    @workplace_mount ||= volume_mounts.find_or_create_by!(volume: nil) do |vm|
      # volume_name will be generated by the before_validation callback
    end
  end

  def branches
    @branches ||= fetch_branches(self)
  end

  def total_cost
    runs.joins(:steps).where.not(steps: { cost_usd: nil }).sum("steps.cost_usd")
  end

  def total_tokens
    {
      input: runs.joins(:steps).where.not(steps: { input_tokens: nil }).sum("steps.input_tokens"),
      output: runs.joins(:steps).where.not(steps: { output_tokens: nil }).sum("steps.output_tokens"),
      cache_creation: runs.joins(:steps).where.not(steps: { cache_creation_tokens: nil }).sum("steps.cache_creation_tokens"),
      cache_read: runs.joins(:steps).where.not(steps: { cache_read_tokens: nil }).sum("steps.cache_read_tokens")
    }
  end

  def docker_env_strings(additional_vars = [])
    agent.env_strings + project.env_strings + user.env_strings + additional_vars
  end

  def latest_repo_state
    RepoState
      .joins(step: :run)
      .where(runs: { task_id: id })
      .order("runs.created_at DESC, steps.created_at DESC")
      .first
  end


  private

  def create_volume_mounts
    agent.volumes.each do |volume|
      volume_mounts.find_or_create_by!(volume: volume)
    end
    workplace_mount # Create workplace mount
  end

  def set_default_description
    self.description ||= "#{agent.name} in #{project.name}" if agent && project
  end
end
